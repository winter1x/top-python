Структура папки: C:\Users\Ефимов\pythonProjects\top-python\online\django_blog\django_blog\article

- __init__.py
    [Содержимое файла: __init__.py]
- admin.py
    [Содержимое файла: admin.py]
    from django.contrib import admin
    from .models import Article, Comment
    from django.contrib.admin import DateFieldListFilter
    
    @admin.register(Article)
    class ArticleAdmin(admin.ModelAdmin):
        list_display = (
            'name',
            'created_at',
        )
        search_fields = ['name', 'body']
        list_filter = (
            ('created_at', DateFieldListFilter),
        )
    
    @admin.register(Comment)
    class CommentAdmin(admin.ModelAdmin):
        list_display = (
            "author",
            'article',
            'text',
            "created_at",
        )
        search_fields = ['author__username', 'text']
        list_filter = (
            ('created_at', DateFieldListFilter),
        )
    
- apps.py
    [Содержимое файла: apps.py]
    from django.apps import AppConfig
    
    
    class ArticleConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'django_blog.article'
- forms.py
    [Содержимое файла: forms.py]
    from django import forms
    from .models import Comment
    
    # class ArticleCommentForm(forms.Form):
    #     text = forms.CharField(label="Комментарий", max_length=200, required=True)
    #     email = forms.EmailField(required=True)
    #     age = forms.IntegerField(min_value=0, max_value=120, required=False)
    
    #     def clean_text(self):
    #         text = self.cleaned_data['text']
    #         if "спам" in text.lower():
    #             raise forms.ValidationError(
    #                 "Нельзя использовать спам в комментариях!"
    #             )
    #         return text
    
    class ArticleCommentForm(forms.ModelForm):
        class Meta:
            model = Comment
            fields = ['title', 'text']
            labels = {
                'title': 'Заголовок',
                'text': 'Комментарий',
            }
            widgets = {
                'title': forms.TextInput(attrs={'placeholder': 'Заголовок комментария'}),
                'text': forms.Textarea(attrs={'rows': 3, 'placeholder': 'Текст комментария'}),
            }
    
        def clean_text(self):
            content = self.cleaned_data['text']
            if "спам" in content.lower():
                raise forms.ValidationError(
                    "Нельзя использовать спам в комментариях!"
                )
            return content
    
    # class PasswordChangeForm(forms.Form):
    #     password = forms.CharField(widget=forms.PasswordInput, required=True)
    #     password_confirm = forms.CharField(widget=forms.PasswordInput, required=True)
    
    #     def clean(self):
    #         cleaned_data = super().clean()
    #         password = cleaned_data.get('password')
    #         password_confirm = cleaned_data.get('password_confirm')
    
    #         if password and password_confirm and password != password_confirm:
    #             raise forms.ValidationError("Пароли не совпадают!")
    
    #         return cleaned_data
[Папка] migrations/
    - 0001_initial.py
        [Содержимое файла: 0001_initial.py]
        # Generated by Django 5.2.1 on 2025-09-05 13:27
        
        import django.db.models.deletion
        from django.conf import settings
        from django.db import migrations, models
        
        
        class Migration(migrations.Migration):
        
            initial = True
        
            dependencies = [
                migrations.swappable_dependency(settings.AUTH_USER_MODEL),
            ]
        
            operations = [
                migrations.CreateModel(
                    name='Article',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('name', models.CharField(max_length=200)),
                        ('body', models.TextField()),
                        ('created_at', models.DateTimeField(auto_now_add=True)),
                        ('updated_at', models.DateTimeField(auto_now=True)),
                    ],
                ),
                migrations.CreateModel(
                    name='Comment',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('title', models.CharField(max_length=100, verbose_name='title')),
                        ('text', models.CharField(max_length=200, verbose_name='text')),
                        ('created_at', models.DateTimeField(auto_now_add=True)),
                        ('article', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='comments', to='article.article')),
                        ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='comments', to=settings.AUTH_USER_MODEL)),
                    ],
                ),
            ]
    - __init__.py
        [Содержимое файла: __init__.py]
- models.py
    [Содержимое файла: models.py]
    from django.db import models
    from django_blog.users.models import BlogUser
    from django.contrib.auth import get_user_model
    
    class Article(models.Model):
        name = models.CharField(max_length=200)
        body = models.TextField()
        created_at = models.DateTimeField(auto_now_add=True)
        updated_at = models.DateTimeField(auto_now=True)
    
        def __str__(self):
            return self.name
    
    class Comment(models.Model):
        article = models.ForeignKey(
            Article,
            on_delete=models.CASCADE,
            related_name='comments',
        )
        author = models.ForeignKey(
            get_user_model(),
            on_delete=models.CASCADE,
            related_name='comments',
        )
        title = models.CharField('title', max_length=100, blank=False)
        text = models.CharField("text", max_length=200)
        created_at = models.DateTimeField(auto_now_add=True)
    
        def __str__(self):
            return f"Комментарий от {self.author} к статье {self.article.name}"
[Папка] templates/
- tests.py
    [Содержимое файла: tests.py]
    from django.test import TestCase
    
    # Create your tests here.
- urls.py
    [Содержимое файла: urls.py]
    from django.urls import path
    from django_blog.article import views
    from django_blog.article.views import IndexView, ArticleView, ArticleCommentView, CommentCreateView, CommentEditView
    
    urlpatterns = [
        path("<str:tags>/<int:article_id>", views.index, name="article"),
        path("", IndexView.as_view(), name="article_index"),
        path("<int:id>/", ArticleView.as_view(), name="article_view"),
        path("<int:article_id>/comments/", ArticleCommentView.as_view(), name="article_comments"),
        path("<int:article_id>/comments/create/", CommentCreateView.as_view(), name="comment_create"),
        path("<int:article_id>/comments/<int:comment_id>/edit/", CommentEditView.as_view(), name="comment_edit"),
    ]
- views.py
    [Содержимое файла: views.py]
    from django.shortcuts import render, redirect, get_object_or_404
    from django.http import HttpResponse
    from django.views import View
    from django.urls import reverse
    from django_blog.article.models import Article, Comment, BlogUser
    from django_blog.article.forms import ArticleCommentForm
    
    def index(request, tags, article_id):
        return HttpResponse(f'Статья {article_id} с тегом {tags}')
    
    class IndexView(View):
        def get(self, request, *args, **kwargs):
            articles = Article.objects.all()[:15]
            return render(
                request,
                "articles/index.html",
                context={
                    "articles": articles
                },
            )
    
    class ArticleView(View):
        def get(self, request, *args, **kwargs):
            article = get_object_or_404(Article, id=kwargs['id'])
            return render(
                request,
                "articles/show.html",
                context={
                    "article": article
                },
            )
    
    class ArticleCommentView(View):
        def get(self, request, *args, **kwargs):
            article = get_object_or_404(Article, id=kwargs['article_id'])
            comments = Comment.objects.filter(article__id=kwargs['article_id'])
            return render(
                request,
                "articles/comments.html",
                context={
                    "article": article,
                    "comments": comments
                },
            )
    
    class CommentCreateView(View):
        # def post(self, request, *args, **kwargs):
        #     article = get_object_or_404(Article, id=kwargs['article_id'])
        #     form = ArticleCommentForm(request.POST)
    
        #     if form.is_valid():
        #         Comment.objects.create(
        #             text=form.cleaned_data["text"],
        #             article=article,
        #             author=request.user
        #         )
        #         return redirect('article_comments', article_id=article.id)
    
        #     return render(
        #         request,
        #         "articles/create.html",
        #         context={
        #             "article": article,
        #             "form": form
        #         },
        #     )
    
        # def get(self, request, *args, **kwargs):
        #     article = get_object_or_404(Article, id=kwargs['article_id'])
        #     form = ArticleCommentForm()
        #     return render(request, "articles/comments.html", context={"article": article, "form": form})
    
        def post(self, request, *args, **kwargs):
            article = get_object_or_404(Article, id=kwargs['article_id'])
            form = ArticleCommentForm(request.POST)
            if form.is_valid():
                comment = form.save(commit=False)
                #comment.text = check_for_spam(form.cleaned_data["text"])
                comment.author = request.user
                comment.article = article
                comment.save()
                return redirect('article_comments', article_id=article.id)
            return render(request, "articles/create.html", context={"form": form, "article": article})
    
        def get(self, request, *args, **kwargs):
            article = get_object_or_404(Article, id=kwargs['article_id'])
            form = ArticleCommentForm()
            return render(request, "articles/create.html", context={"form": form, "article": article})
    
    class CommentEditView(View):
        def get(self, request, article_id, comment_id, *args, **kwargs):
            comment = get_object_or_404(Comment, id=comment_id, article__id=article_id)
            article = comment.article
            form = ArticleCommentForm(instance=article)
            return render(request, "articles/create.html", context={"form": form, "article": article, "edit": True})
    
        def post(self, request, article_id, comment_id, *args, **kwargs):
            comment = get_object_or_404(Comment, id=comment_id, article__id=article_id)
            article = comment.article
    
            form = ArticleCommentForm(request.POST, instance=article)
    
            if form.is_valid():
                form.save()
                return redirect('article_comments', article_id=article.id)
    
            return render(request, "articles/create.html", context={"form": form, "article": article, "edit": True})
